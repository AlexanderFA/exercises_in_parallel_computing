#include <iostream>
#include <omp.h>

int main() {
    int k = 3, N = 20;
    
    #pragma omp parallel num_threads(k)
    {
        #pragma omp for schedule(guided, 2)
        for (int i = 0; i < N; ++i) {
            printf("[%d]: calculation of the iteration number %d.\n", omp_get_thread_num(), i+1);
        }
    }

    return 0;
}
//Структура итераций цикла: Если все итерации цикла требуют примерно одинакового времени выполнения, то статическое распределение (schedule(static)) может быть эффективным выбором. Если же итерации имеют разную длительность выполнения, то динамическое распределение (schedule(dynamic)) или режим guided могут быть более подходящими.
//
//Равномерность нагрузки: Если все итерации цикла имеют одинаковую сложность и время выполнения, статическое распределение может обеспечить более равномерную нагрузку на потоки. Динамическое и guided распределение полезны, когда нагрузка неоднородна.
//
//Размер задачи и доступные ресурсы: Для крупных задач и многоядерных систем часто эффективно использовать более крупные порции итераций (большие значения параметра chunk), чтобы уменьшить накладные расходы на управление потоками. Для мелких задач и/или систем с небольшим количеством ядер могут быть предпочтительны более мелкие порции.
//
//Балансировка нагрузки: Если требуется балансировать нагрузку между потоками, можно использовать динамическое распределение (schedule(dynamic)), а также режим guided.
//
//Общая производительность: Выбор параметра schedule также может зависеть от общей производительности программы на конкретной архитектуре. Рекомендуется провести тестирование и настройку параметров для оптимальной производительности в конкретных условиях.
