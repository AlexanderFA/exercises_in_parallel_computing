#include <omp.h>
#include <stdio.h>

int main() {
    int rank, k, N;
    printf("Введите количество нитей (k): ");
    scanf("%d", &k);
    printf("Введите (N): ");
    scanf("%d", &N);

    int sum = 0; // Переменная для общей суммы

    // за счет reduction sum превращается в локальную переменную и по выходу из функции складывается, то есть это похоже на private но с оператором (в данном случае сложение)
    #pragma omp parallel num_threads(k) private(rank) reduction(+:sum)
    {
        rank = omp_get_thread_num(); // Получаем номер нити

        // вычисляем размер порции данных для каждой нити. Мы делим общее количество чисел N на количество нитей k. Это определяет, сколько чисел будет обрабатывать каждая нить.
        int portion_size = N / k;
        // вычисляем начальный индекс для каждой нити. Номер нити rank умножается на размер порции portion_size, затем к результату добавляется 1, потому что нумерация чисел начинается с 1.
        int start = rank * portion_size + 1;
        // вычисляем конечный индекс для каждой нити. Если нить является последней (rank == k - 1), то ей назначается оставшаяся часть чисел (N - start + 1). В противном случае, конечный индекс вычисляется как начальный индекс плюс размер порции минус 1.
        int end = (rank == k - 1) ? N : start + portion_size - 1;

        // Вычисляем частичную сумму для каждой нити
        for (int i = start; i <= end; ++i) {
            sum += i;
        }

        // Выводим частичную сумму для каждой нити
        printf("[%d]: Sum = %d\n", rank, sum);
    }

    // Выводим общую сумму
    printf("Sum = %d\n", sum);

    return 0;
}
